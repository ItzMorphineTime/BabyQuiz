<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dynamic JSON Quiz</title>
  <style>
    :root{
      --bg: #0b1020;
      --bg-soft:#121938;
      --card:#0f1530;
      --text:#e9ecf5;
      --muted:#b9c1dd;
      --accent:#7c9cff;
      --accent-2:#62e0a4;
      --danger:#ff6b6b;
      --warn:#ffd166;
      --border:rgba(255,255,255,.12);
      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f8ff; --bg-soft:#eef2ff; --card:#ffffff; --text:#0c1430; --muted:#48527a; --accent:#355cff; --accent-2:#0aa36c; --danger:#d84747; --warn:#c48d00; --border:rgba(10,16,40,.12); --shadow:0 10px 30px rgba(18,27,78,.08), inset 0 1px 0 rgba(255,255,255,.7);
      }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:linear-gradient(180deg,var(--bg),var(--bg-soft) 60%); color:var(--text)}
    a{color:var(--accent)}
    .wrap{max-width:1100px; margin:40px auto; padding:0 16px}

    .app{display:grid; grid-template-columns: 360px 1fr; gap:22px}
    @media (max-width: 980px){.app{grid-template-columns: 1fr}}

    .panel{background:var(--card); border:1px solid var(--border); border-radius:18px; box-shadow:var(--shadow)}
    .panel h2{margin:0 0 12px 0; font-size:20px}
    .panel .inner{padding:18px}

    .control{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 14px}
    .control label{font-size:14px; color:var(--muted)}

    textarea#jsonInput{width:100%; min-height:180px; resize:vertical; padding:12px; border-radius:12px; border:1px solid var(--border); background:rgba(0,0,0,.06); color:var(--text); font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    .drop{border:1px dashed var(--border); border-radius:12px; padding:12px; text-align:center; color:var(--muted); font-size:14px}
    .drop.dragover{border-color:var(--accent)}

    .btn{appearance:none; border:1px solid var(--border); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.05)); color:var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; box-shadow:var(--shadow); transition:transform .02s ease-in, border-color .2s;}
    .btn:hover{transform:translateY(-1px); border-color:var(--accent)}
    .btn.accent{background: linear-gradient(180deg, var(--accent), #3e74ff); border-color: transparent; color:white}
    .btn.ghost{background:transparent}
    .btn.warn{background:linear-gradient(180deg, var(--warn), #f7c543); color:#1a1200; border-color:transparent}
    .btn.danger{background:linear-gradient(180deg, var(--danger), #f04d4d); color:white; border-color:transparent}
    .btn.small{padding:6px 10px; font-weight:600; font-size:12px; border-radius:10px}

    .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between; margin:4px 0 8px}
    .toolbar .left, .toolbar .right{display:flex; gap:8px; align-items:center; flex-wrap:wrap}

    .stat{display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid var(--border); border-radius:12px; font-size:14px; color:var(--muted)}

    .quiz{display:flex; flex-direction:column; gap:14px; padding:12px}

    .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.06)); border:1px solid var(--border); border-radius:16px; padding:16px}
    .qhead{display:flex; gap:8px; align-items:baseline; justify-content:space-between}
    .qid{font-size:12px; color:var(--muted)}
    .qtext{font-size:18px; font-weight:700; margin:6px 0 2px}

    .choices{margin-top:10px; display:grid; gap:8px}
    .choice{display:flex; gap:10px; align-items:flex-start; padding:10px 12px; border:1px solid var(--border); border-radius:12px; cursor:pointer}
    .choice input{transform: translateY(2px)}
    .choice.correct{outline:2px solid var(--accent-2)}
    .choice.wrong{outline:2px solid var(--danger)}

    .actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:12px}
    .explain{margin-top:8px; font-size:14px; color:var(--muted); display:none}
    .explain.show{display:block}
    .explain strong{color:var(--text)}

    .error{background:#2a1020; border:1px solid rgba(255,0,120,.25); color:#ffd5ea; padding:10px 12px; border-radius:12px; font-size:14px; white-space:pre-wrap}

    .footer{margin-top:14px; display:flex; gap:10px; flex-wrap:wrap}
    .hidden{display:none !important}
  </style>
</head>
<body>
  <div class="wrap">
    <header style="margin:0 0 18px 2px">
      <h1 style="margin:0; font-size:28px">Dynamic JSON Quiz</h1>
      <p style="margin:6px 0 0; color:var(--muted); max-width:80ch">Paste JSON or upload a file, then generate an interactive MCQ quiz. Supports explanations and references. Your progress is saved locally.</p>
    </header>

    <div class="app">
      <!-- Input Panel -->
      <section class="panel" aria-label="Input">
        <div class="inner">
          <h2>1) Provide your JSON</h2>
          <div class="control">
            <button id="btnSample" class="btn small">Load sample</button>
            <button id="btnTemplate" class="btn small ghost">Copy template</button>
          </div>
          <textarea id="jsonInput" placeholder="Paste your quiz JSON here..."></textarea>
          <div class="control">
            <label for="file">Or upload a .json file</label>
            <input id="file" type="file" accept="application/json,.json" />
          </div>
          <div id="drop" class="drop" tabindex="0" aria-label="Drop zone">Drag & drop a JSON file here</div>

          <h2 style="margin-top:18px">2) Options</h2>
          <div class="control">
            <label><input type="checkbox" id="shuffleChoices" checked> Shuffle choices</label>
            <label><input type="checkbox" id="instantReveal"> Reveal explanation immediately</label>
          </div>
          <div class="control">
            <label><input type="checkbox" id="persistState" checked> Save progress (local)</label>
          </div>

          <div class="control">
            <button id="btnBuild" class="btn accent">Build Quiz</button>
            <button id="btnReset" class="btn ghost">Reset</button>
          </div>
          <div id="errors" class="error hidden" role="alert" aria-live="polite"></div>
        </div>
      </section>

      <!-- Quiz Panel -->
      <section class="panel" aria-label="Quiz">
        <div class="inner">
          <div class="toolbar">
            <div class="left">
              <div class="stat" id="statCount">Questions: 0</div>
              <div class="stat" id="statScore" aria-live="polite">Score: 0</div>
              <div class="stat" id="statDone">Answered: 0</div>
            </div>
            <div class="right">
              <button id="btnCheckAll" class="btn small">Check all</button>
              <button id="btnShowAllWhy" class="btn small">Show all explanations</button>
              <button id="btnExport" class="btn small">Export results (CSV)</button>
            </div>
          </div>
          <div id="quiz" class="quiz" aria-live="polite"></div>
        </div>
      </section>
    </div>

    <footer class="footer">
      <small style="color:var(--muted)">Tip: Use letters (A–E) to select an option when a question is focused. Your data never leaves the browser.</small>
    </footer>
  </div>

<script>
(() => {
  const el = (sel, ctx=document) => ctx.querySelector(sel);
  const els = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));
  const state = {
    quiz: [], // normalized questions
    options: { shuffleChoices: true, instantReveal: false, persist: true },
    user: new Map(), // key: qid, value: { selectedKey, correct, checkedAt }
  };
  const dom = {
    jsonInput: el('#jsonInput'),
    file: el('#file'),
    drop: el('#drop'),
    errors: el('#errors'),
    btnBuild: el('#btnBuild'),
    btnReset: el('#btnReset'),
    btnSample: el('#btnSample'),
    btnTemplate: el('#btnTemplate'),
    shuffleChoices: el('#shuffleChoices'),
    instantReveal: el('#instantReveal'),
    persistState: el('#persistState'),
    quizRoot: el('#quiz'),
    statCount: el('#statCount'),
    statScore: el('#statScore'),
    statDone: el('#statDone'),
    btnCheckAll: el('#btnCheckAll'),
    btnShowAllWhy: el('#btnShowAllWhy'),
    btnExport: el('#btnExport'),
  };

  const SAMPLE = `[
  {
    "id": 2228,
    "question": "All of the following are structural incompatibilities of the articular surfaces of the TM joints except one. Which one is the exception?",
    "options": {
      "a": "Spontaneous dislocation",
      "b": "Deviation in form",
      "c": "Subluxation",
      "d": "Adhesion",
      "e": "Protective co-contraction"
    },
    "answer": "e",
    "why": "Protective co-contraction is a neuromuscular protective response, not a structural incompatibility of joint surfaces; the others are mechanical/structural disorders.",
    "reference": "Okeson JP. Management of Temporomandibular Disorders, 8th ed., Ch. 1, Elsevier, 2012."
  },
  {
    "id": 2229,
    "question": "A study by Pullinger and Seligman on the predictive values of occlusal variables on temporomandibular disorders reported that:",
    "options": {
      "a": "Dental occlusion was a cofactor that accounted for 73–95% of the likelihood of developing temporomandibular disorders.",
      "b": "Horizontal overlap (overjet) > 5 mm was more commonly associated with osteoarthrosis.",
      "c": "Patients with unilateral crossbite were less likely to have disk displacements.",
      "d": "Horizontal overlap (overjet) < 1 mm was more commonly associated with patients with temporomandibular disorders."
    },
    "answer": "d",
    "why": "Pullinger & Seligman found occlusal factors had modest predictive value; minimal overjet (<1 mm) showed association with TMD. (a) overstates occlusion’s role, (b) concerns osteoarthrosis specifically, and (c) is not supported.",
    "reference": "Pullinger AG, Seligman DA. J Prosthet Dent. 2000;83:66–75."
  }
]`;

  const TEMPLATE = `[
  {
    "id": 1,
    "question": "Your question text here",
    "options": {"a":"Option A", "b":"Option B", "c":"Option C", "d":"Option D"},
    "answer": "a",
    "why": "Explain why the correct answer is correct.",
    "reference": "Optional reference or citation."
  }
]`;

  // Utilities
  function normalize(rawArray){
    // returns array of {id, question, choices:[{key,text,isCorrect}], ref, why}
    return rawArray.map((q, idx) => {
      if(!q || typeof q !== 'object') throw mkErr(idx, 'Question must be an object');
      const id = (q.id ?? idx+1).toString();
      if(!q.question || typeof q.question !== 'string') throw mkErr(idx, 'Missing "question" string');
      if(!q.options || typeof q.options !== 'object') throw mkErr(idx, 'Missing "options" object');
      const entries = Object.entries(q.options);
      if(entries.length < 2) throw mkErr(idx, 'Provide at least two options');
      const answerKey = (q.answer ?? '').toString().trim().toLowerCase();
      if(!answerKey) throw mkErr(idx, 'Missing "answer" key (e.g., "a")');
      const choices = entries.map(([key, text]) => ({
        key: key.toString().trim().toLowerCase(),
        text: String(text ?? ''),
        isCorrect: key.toString().trim().toLowerCase() === answerKey
      }));
      if(!choices.some(c => c.isCorrect)) throw mkErr(idx, `Answer key "${answerKey}" not found among options`);
      return {
        id,
        question: q.question,
        choices,
        why: q.why ? String(q.why) : '',
        reference: q.reference ? String(q.reference) : ''
      };
    });
  }
  function mkErr(idx, msg){
    return new Error(`Q${idx+1}: ${msg}`);
  }
  const shuffle = (arr) => {
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
    return a;
  };
  function saveLocal(){
    if(!state.options.persist) return;
    const payload = {
      quiz: state.quiz.map(q => ({ id:q.id, choices:q.choices.map(c=>({key:c.key,text:c.text,isCorrect:c.isCorrect})) , question:q.question, why:q.why, reference:q.reference })),
      user: Array.from(state.user.entries()),
      options: state.options,
      savedAt: Date.now()
    };
    localStorage.setItem('quiz_app_v2', JSON.stringify(payload));
  }
  function loadLocal(){
    try{
      const raw = localStorage.getItem('quiz_app_v2');
      if(!raw) return null;
      const data = JSON.parse(raw);
      state.options = Object.assign(state.options, data.options||{});
      state.quiz = (data.quiz||[]);
      state.user = new Map(data.user||[]);
      applyOptionToggles();
      renderQuiz();
      notify(`Restored ${state.quiz.length} questions from a previous session.`);
      return true;
    }catch{ return null; }
  }
  function clearLocal(){ localStorage.removeItem('quiz_app_v2'); }

  // Rendering
  function renderQuiz(){
    dom.quizRoot.innerHTML = '';
    dom.errors.classList.add('hidden');

    const frag = document.createDocumentFragment();
    state.quiz.forEach((q, index) => {
      const card = document.createElement('section');
      card.className = 'card';
      card.tabIndex = 0; // focusable for keyboard letters
      card.dataset.qid = q.id;

      const head = document.createElement('div');
      head.className = 'qhead';
      const title = document.createElement('div');
      title.innerHTML = `<div class="qid">Question ${index+1}${q.id?` · ID ${escapeHTML(q.id)}`:''}</div><div class="qtext"></div>`;
      title.querySelector('.qtext').textContent = q.question;
      head.appendChild(title);

      const actionsRight = document.createElement('div');
      actionsRight.innerHTML = '';
      head.appendChild(actionsRight);

      const choicesWrap = document.createElement('div');
      choicesWrap.className = 'choices';
      const choices = state.options.shuffleChoices ? shuffle(q.choices) : q.choices;

      choices.forEach((c, idx) => {
        const label = document.createElement('label');
        label.className = 'choice';
        label.setAttribute('data-key', c.key);
        label.innerHTML = `
          <input type="radio" name="q_${q.id}" value="${escapeHTML(c.key)}" />
          <div>
            <div style="font-weight:700">${String.fromCharCode(65+idx)}. <span class="opt"></span></div>
            <div class="meta" style="color:var(--muted); font-size:12px">Key: ${c.key.toUpperCase()}</div>
          </div>`;
        label.querySelector('.opt').textContent = c.text;
        choicesWrap.appendChild(label);
      });

      const buttons = document.createElement('div');
      buttons.className = 'actions';
      buttons.innerHTML = `
        <button class="btn small" data-act="check">Check answer</button>
        <button class="btn small ghost" data-act="clear">Clear</button>
        <button class="btn small ghost" data-act="reveal">Reveal answer</button>`;

      const explain = document.createElement('div');
      explain.className = 'explain';
      explain.innerHTML = formatExplain(q);

      card.append(head, choicesWrap, buttons, explain);
      frag.appendChild(card);

      // restore selection from state
      const saved = state.user.get(q.id);
      if(saved?.selectedKey){
        const input = card.querySelector(`input[value="${cssEscape(saved.selectedKey)}"]`);
        if(input){ input.checked = true; }
        if(saved.correct !== undefined){ markResult(card, saved.correct ? saved.selectedKey : saved.selectedKey, q); }
        if(saved.correct !== undefined){
          // show explanation after checked
          explain.classList.add('show');
        }
      }

      // keyboard shortcuts: A-E
      card.addEventListener('keydown', (ev) => {
        const key = ev.key.toLowerCase();
        if(key>='a' && key<='z'){
          const lab = choicesWrap.querySelector(`label[data-key="${cssEscape(key)}"] input`);
          if(lab){ lab.checked = true; saveSelection(q.id, key); if(state.options.instantReveal){ check(card, q); } }
        }
      });

      // delegate clicks
      buttons.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-act]');
        if(!btn) return;
        const act = btn.dataset.act;
        if(act==='check') check(card, q);
        if(act==='clear') clearSelection(card, q);
        if(act==='reveal') { reveal(card, q); }
      });

      // change selection
      choicesWrap.addEventListener('change', (e) => {
        if(e.target && e.target.name === `q_${q.id}`){
          const selectedKey = e.target.value;
          saveSelection(q.id, selectedKey);
          if(state.options.instantReveal){ check(card, q); }
        }
      });
    });

    dom.quizRoot.appendChild(frag);
    updateStats();
    saveLocal();
  }

  function formatExplain(q){
    const parts = [];
    if(q.why){ parts.push(`<p><strong>Why:</strong> ${escapeHTML(q.why)}</p>`); }
    if(q.reference){ parts.push(`<p><strong>Reference:</strong> ${linkify(escapeHTML(q.reference))}</p>`); }
    return parts.join('') || '<p><em>No explanation provided.</em></p>';
  }

  function saveSelection(qid, key){
    const u = state.user.get(qid) || {};
    u.selectedKey = key;
    state.user.set(qid, u);
    saveLocal();
    updateStats();
  }

  function clearSelection(card, q){
    els('input[type="radio"]', card).forEach(i => i.checked = false);
    els('.choice', card).forEach(c => c.classList.remove('correct','wrong'));
    const u = state.user.get(q.id) || {};
    delete u.selectedKey; delete u.correct; delete u.checkedAt;
    state.user.set(q.id, u);
    const ex = card.querySelector('.explain');
    ex.classList.remove('show');
    saveLocal();
    updateStats();
  }

  function check(card, q){
    const sel = card.querySelector('input[type="radio"]:checked');
    if(!sel){ return notify('Select an option first.'); }
    const key = sel.value;
    const isCorrect = q.choices.find(c => c.key === key)?.isCorrect === true;
    markResult(card, key, q, isCorrect);
    const u = state.user.get(q.id) || {};
    u.selectedKey = key; u.correct = !!isCorrect; u.checkedAt = Date.now();
    state.user.set(q.id, u);
    card.querySelector('.explain').classList.add('show');
    saveLocal();
    updateStats();
  }
  function reveal(card, q){
    const correct = q.choices.find(c => c.isCorrect);
    if(!correct) return;
    // select it visually
    const input = card.querySelector(`input[value="${cssEscape(correct.key)}"]`);
    if(input){ input.checked = true; }
    markResult(card, correct.key, q, true);
    const u = state.user.get(q.id) || {};
    u.selectedKey = correct.key; u.correct = true; u.checkedAt = Date.now();
    state.user.set(q.id, u);
    card.querySelector('.explain').classList.add('show');
    saveLocal();
    updateStats();
  }

  function markResult(card, selectedKey, q, isCorrect = null){
    els('.choice', card).forEach(lbl => lbl.classList.remove('correct','wrong'));
    // mark selected
    const selectedLabel = card.querySelector(`label[data-key="${cssEscape(selectedKey)}"]`);
    if(selectedLabel){ selectedLabel.classList.add(isCorrect? 'correct':'wrong'); }
    // always mark the actual correct choice with a subtle border if wrong selected
    if(isCorrect === false){
      const correct = q.choices.find(c => c.isCorrect);
      if(correct){ const lab = card.querySelector(`label[data-key="${cssEscape(correct.key)}"]`); lab?.classList.add('correct'); }
    }
  }

  function updateStats(){
    const total = state.quiz.length;
    const answered = Array.from(state.user.values()).filter(v => v.correct !== undefined).length;
    const score = Array.from(state.user.values()).filter(v => v.correct === true).length;
    dom.statCount.textContent = `Questions: ${total}`;
    dom.statDone.textContent = `Answered: ${answered}`;
    dom.statScore.textContent = `Score: ${score}`;
  }

  function buildFromText(text){
    try{
      const arr = JSON.parse(text);
      if(!Array.isArray(arr)) throw new Error('Top-level JSON must be an array of question objects.');
      const normalized = normalize(arr);
      state.quiz = normalized;
      state.user = new Map();
      renderQuiz();
      notify(`Loaded ${normalized.length} questions.`);
    }catch(err){ showError(err.message || String(err)); }
  }

  function showError(msg){
    dom.errors.textContent = msg;
    dom.errors.classList.remove('hidden');
  }
  function notify(msg){
    dom.errors.textContent = msg;
    dom.errors.classList.remove('hidden');
    setTimeout(() => dom.errors.classList.add('hidden'), 2000);
  }

  function linkify(text){
    // simple URL detection
    return text.replace(/(https?:\/\/[^\s)]+)(\)?)/g, '<a target="_blank" rel="noopener" href="$1">$1</a>$2');
  }
  function escapeHTML(str){
    return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }
  function cssEscape(str){
    // minimal escaper for attribute selectors
    return str.replace(/"/g, '\\"');
  }

  // Export CSV
  function exportCSV(){
    if(!state.quiz.length){ return notify('Build a quiz first.'); }
    const rows = [['id','question','selected_key','correct','checked_at']];
    state.quiz.forEach(q => {
      const u = state.user.get(q.id) || {};
      rows.push([q.id, q.question.replace(/\n/g,' '), u.selectedKey||'', u.correct===true?'TRUE':u.correct===false?'FALSE':'', u.checkedAt?new Date(u.checkedAt).toISOString():'']);
    });
    const csv = rows.map(r => r.map(cell => '"'+String(cell).replace(/"/g,'""')+'"').join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'quiz_results.csv'; a.click(); URL.revokeObjectURL(url);
  }

  function applyOptionToggles(){
    dom.shuffleChoices.checked = !!state.options.shuffleChoices;
    dom.instantReveal.checked = !!state.options.instantReveal;
    dom.persistState.checked = !!state.options.persist;
  }

  // Handlers
  dom.btnSample.addEventListener('click', () => { dom.jsonInput.value = SAMPLE; });
  dom.btnTemplate.addEventListener('click', async () => {
    try{
      await navigator.clipboard.writeText(TEMPLATE);
      notify('Template copied to clipboard.');
    }catch{ dom.jsonInput.value = TEMPLATE; notify('Template placed into the textarea.'); }
  });

  dom.file.addEventListener('change', (e) => {
    const f = e.target.files?.[0]; if(!f) return;
    const reader = new FileReader();
    reader.onload = () => { dom.jsonInput.value = String(reader.result||''); };
    reader.readAsText(f);
  });

  // Drag & drop
  ;['dragenter','dragover'].forEach(evt => dom.drop.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); dom.drop.classList.add('dragover'); }));
  ;['dragleave','drop'].forEach(evt => dom.drop.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); dom.drop.classList.remove('dragover'); }));
  dom.drop.addEventListener('drop', (e)=>{
    const f = e.dataTransfer.files?.[0]; if(!f) return;
    if(!/\.json$/i.test(f.name)){ return showError('Please drop a .json file.'); }
    const reader = new FileReader();
    reader.onload = () => { dom.jsonInput.value = String(reader.result||''); };
    reader.readAsText(f);
  });

  dom.btnBuild.addEventListener('click', () => {
    state.options.shuffleChoices = dom.shuffleChoices.checked;
    state.options.instantReveal = dom.instantReveal.checked;
    state.options.persist = dom.persistState.checked;
    if(!dom.jsonInput.value.trim()){ return showError('Paste JSON or upload a file first.'); }
    buildFromText(dom.jsonInput.value.trim());
  });

  dom.btnReset.addEventListener('click', () => {
    state.quiz = []; state.user = new Map(); dom.quizRoot.innerHTML=''; updateStats(); clearLocal();
  });

  dom.btnCheckAll.addEventListener('click', () => {
    els('.card').forEach((card, i) => {
      const id = card.dataset.qid;
      const q = state.quiz.find(x => x.id === id);
      if(q) check(card, q);
    });
  });

  dom.btnShowAllWhy.addEventListener('click', () => {
    els('.explain').forEach(x => x.classList.add('show'));
  });

  dom.btnExport.addEventListener('click', exportCSV);

  dom.persistState.addEventListener('change', () => { state.options.persist = dom.persistState.checked; if(!state.options.persist) clearLocal(); else saveLocal(); });

  // Try to restore previous session
  loadLocal();
})();
</script>
</body>
</html>
